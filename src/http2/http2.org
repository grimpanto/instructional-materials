#+TITLE: Verteilte Systeme \linebreak \small \mbox{ } \hfill HTTP 2 (Quelle: haupts√§chlich =https://daniel.haxx.se/http2=)
#+AUTHOR: Dr. G√ºnter Kolousek
#+DATE: \copy Dr. G√ºnter Kolousek \hspace{12ex} [[http://creativecommons.org/licenses/by-nc-nd/4.0/][Creative Commons Namensnennung - Nicht kommerziell - Keine Bearbeitungen 4.0 International Lizenz]]

#+OPTIONS: H:1 toc:nil
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: Execushares
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col) %8BEAMER_OPT(Opt)

#+Latex_HEADER:\usepackage{pgfpages}
# +LATEX_HEADER:\pgfpagesuselayout{2 on 1}[a4paper,border shrink=5mm]u
# +LATEX: \mode<handout>{\setbeamercolor{background canvas}{bg=black!5}}
#+LATEX_HEADER:\usepackage{xspace}
#+LATEX: \newcommand{\cpp}{C++\xspace}

# https://www.heise.de/developer/artikel/Mit-Java-auf-dem-HTTP-2-Zug-3918097.html?view=print

* √úberblick
\vspace{1.5em}
- Nachfolger von HTTP/1.1
  - HTTP/1.1 ist mittlerweile ein umfangreicher Standard
    - keine Implementierung implementiert alles!
    - viele Optionen und Erweiterungsm√∂glichkeiten \to Interoperabilit√§tsprobleme!
  - baut auf SPDY (von Google) auf
- [[https://tools.ietf.org/html/rfc7540][RFC 7540]]
    
* HTTP/1.x und Performance
\vspace{1.3em}
- HTTP/1.0 ... 1 Request ausst√§ndig zu einer Zeit je TCP Verbindung
  \pause
- HTTP/1.1 ... Pipelining
  - aber kein verschr√§nktes Senden und Empfangen
    - au√üer mehrere TCP Verbindungen (diese sind beschr√§nkt: dzt. nicht mehr
      als 6-8 je Site durch Browser)
  - \to HOL Blocking
  \pause
- Allgemein
  - HTTP Header wiederholend und langatmig
    - \to Netzwerkbelastung

* HTTP/2 -- Ziele
- kompatibel zu HTTP/1.1 sein
  - auf gewisser (hohen) Abstraktionsebene
- "Performance" verbessern
  - d.h. Latenz reduzieren
- d.h. Anzahl der TCP Verbindungen reduzieren
  - nur eine Verbindung je Domain
- Sicherheit verbessern

* HTTP/2 -- Features
\vspace{1em}
- Multiplexen mehrerer Requests √ºber eine TCP Verbindung
  - verschr√§nktes Senden und Empfangen
- bin√§res Nachrichtenformat (!) & Komprimierung der Header
- Server Push
  - mehrere Antworten f√ºr einen Request
- Priorisierung der Requests
- Definition eines Profils f√ºr TLS
  - wenn HTTP/2 √ºber TLS

* HTTP/2 -- Multiplexen
- mehrere Streams √ºber /eine/ TCP Verbindung
- Jeder Stream
  - besteht aus einer Folge von Frames
  - hat eine Stream-ID
  - hat eine Priorit√§t (√Ñnderung zur Laufzeit m√∂glich)
  - kann vorzeitig beendet werden
  - hat eine Flusskontrolle (engl. flow control)
    - Schutz des Empf√§ngers vor √úberlastung
- Wirkungen
  - \to Beheben des HOL
  - \to eine Verbindung je Domain \to "Performance"

* HTTP/2 -- Multiplexen -- 2
[[./http2_multiplexing.png]]

\small
Quelle: https://www.nginx.com/blog/http2-module-nginx/

* Bin√§r & Komprimierung der Header
- Bin√§res Format
  - \to bin√§re Daten vs. Textdaten
  - weiters: Komprimierung der Header
- Wirkungen
  - effizienter zu parsen
  - geringere Datenmenge auf der Leitung
  - weniger Fehlerquellen
    - z.B. Behandlung von Whitespace, Gro√ü/Kleinschreibung, Zeilenende,
      Leerzeilen,...
  - \to allg. Verbesserung der "Performance"

* HTTP/2 -- Server Push
- UA sendet Request f√ºr Ressource
- Server antwortet mit HTML /und/ CSS, JS,...
- Wirkungen
  - \to Reduzierung der Latenz

* HTTP/2 -- Priorisierung der Requests
- m√ºssen Client und Server beherrschen
  - Client teilt Server Priorisierung mit
  - dzt. keine M√∂glichkeit f√ºr Frontend-Entwickler diese zu bestimmen
- z.B. HTML \to CSS \to JS \to Bilder
- Wirkungen
  - \to Darstellung einer Seite schneller

* COMMENT Definition eines Profils f√ºr TLS
- mind. TLS 1.2
- m√ºssen zus√§tzlich SNI unterst√ºtzen
  - (Server Name Indication)

* COMMENT HTTP/2 -- Charakterisierung
\vspace{1.5em}
- "schlankes", klar definiertes Protokoll
  - keine optionalen Teile
    - d.h. sp√§ter keine Interoperabilit√§tsprobleme
    - au√üer ein Erweiterungskonzept
  - keine Minor-Version Nummer
    - wenn Weiterentwicklung, dann: HTTP/3
- Komprimierung der Header

* COMMENT HTTP/2 -- Charakterisierung -- 2
- Integration in bestehende Infrastruktur
  - durch Abbildung von HTTP/2 auf HTTP/1.1
  - UA, Proxies, Server
  - Verwendung von ALPN
    - Application-Layer Protocol Negotiation (Erweiterung von TLS)
    - \to aushandeln vom Protokoll, das √ºber TLùïä genutzt wird
    - Weiterentwicklung von NPN (Teil von SPDY)
    - Sinn: unn√∂tige RTT (Round-Trip-Time) vermeiden durch Reduzierung von
      /Round Trips/ (\to Header =Upgrade=)
      
* Funktionsweise
- (vorzugsweise) nur eine TCP Verbindung je Server
  - Empfehlung in RFC 7540: max. #Streams nicht unter 100 konfigurieren!
- Stream: Multiplexing einer TCP Verbindung
  - bidirektional
- Message: ein Stream √ºbertr√§gt Messages
  - Request (=GET=, =POST=,...), Response
- Frame: jede Message besteht aus einem oder mehreren Frames
  - \to kleinste Kommunikationseinheit f√ºr bin√§rkodierte Headerdaten und
    Nutzdaten
    
* Funktionsweise -- 2
- Frame
  - =Length=: 24 Bits
  - =Type=: 8 Bits
  - =Flags=: 8 Bits
  - =R=: reserviert, 1 Bit
  - =Stream Identifier=: 31 Bits (\to Multiplexing)
  - =Frame Payload=

* Funktionsweise -- 3
\vspace{1.5em}
- =Type=
  - =DATA=, =HEADERS=
    - Komprimierung der Header mittels neuem Algo /HPACK/
  - =CONTINUATION= ... zum Senden von weiteren Headerblockfragmenten
  - =SETTINGS= ... einer Verbindung
  - =PRIORITY= ... √Ñndern der Priorit√§t und Abh√§ngigkeit zu anderen Stream
    (Elternstream) herstellen (\to Baum)
    - Ressourcen nur an Kindstream, wenn Elternstream beendet oder kein
      Fortschritt beim Elternstream m√∂glich
  - =GOAWAY= ... beenden eines Streams
  - =RST_STREAM= ... sofortiges Abbrechen eines Streams
    - so etwas geht in HTTP/1.x nicht!
  - =PUSH_PROMISE= ... im Vorhinein mitteilen, dass Stream sp√§ter angelegt wird
  - =PING= ... messen der RTT
  - =WINDOW_UPDATE= ... f√ºr Flusskontrolle

* Webseiten optimieren
\vspace{1em}
- kein Domain Sharding mehr!
  - Urspr√ºngliche Idee: Anzahl der gleichzeitigen Verbindungen durch Verwendung
    von Subdomainen ‚Üë
  - z.B. Aufteilen der Bilder auf =img1.example.com= und =img2.example.com=
  - aber
    - jetzt werden je Subdomain eine neue TLS Verbindung aufgebaut!
    - TCP Slow Start \to anf√§nglich geringere Bandbreite!
- kein Zusammenpacken von CSS und JS mehr!
  - Urspr√ºngliche Idee: Anzahl der zu ladenden Ressourcen reduzieren
  - aber
    - mehrere Dateien \to Priorisierung m√∂glich
    - kein einzelnes Caching m√∂glich\\
      \to √Ñnderungen oder Zuteilung zu einzelnen Seiten

* Webseiten optimieren -- 2
\vspace{1em}
- kein Inlining von CSS und JS in HTML mehr!
  - Urspr√ºngliche Idee: Seite schneller anzeigen k√∂nnen
  - aber
    - HTML Ressourcen deutlich gr√∂√üer
    - kein einzelnes Caching m√∂glich
    - \to HTTP/2 Server Push um Ressourcen vorweg zum Client zu schicken
- HTTP/2 Server Push
  - eigener Push Cache im Browser
  - Daten, die im Browser-Cache liegen br√§uchten nicht gesendet
    werden
    - Browser hat M√∂glichkeit begonnen Push abzubrechen, aber...
    - Internet-Draft vorliegend (Cache Digests): Browser teilt Server mittels
      "Cache Digests" mit, welche Ressourcen schon im Browser Cache

* Kritik
\vspace{1em}
- inkonsistent, unn√∂tige Komplexit√§t, verletzt das Schichten-Prinzip
- de facto Zwang zur Verschl√ºsselung (urspr√ºnglich zwingend!) \to Firefox, Chrome
  - oft nicht ben√∂tigt
  - Ressourcenbedarf \to TLS (Handshake, Verschl√ºsselung)
  - Performance k√∂nnte sinken \to kein Caching!
- verbessert nicht die Privatsph√§re
  - z.B. Cookies bleiben bestehen
    - anstatt z.B. einer vom Client erzeugter Session-ID
  - Vermutung: Gro√üfirmen (wie Google) \to Gesch√§ftsmodell
- verbessert Performance nur wenn CDN verf√ºgbar
  - nicht bei einzelnem Server \to erh√∂hter Aufwand!
\footnotesize haupts√§chlich: http://queue.acm.org/detail.cfm?id=2716278

* Zukunft
\vspace{1.5em}
- Grundlegende Probleme mit HTTP/2
  - basiert auf TCP
  - √§hnliches Problem wie HOL bleibt bestehen
    - Wenn TCP Segmente verloren gehen, dann werden die weiteren
      schon eingetroffenen Segmente erst best√§tigt, wenn das verlorenen
      gegangene Segment nochmals gesendet und eingetroffen ist!
    - speziell bei unzuverl√§ssigen Kommunikationskan√§len ein Problem,
      wie z.B. bei mobilen Ger√§ten
- deshalb: HTTP/3
  - HTTP √ºber QUIC
  - wird von IETF standardisiert
  - wird schon verwendet von
    - Chrome (70% Marktanteil!)
    - der Facebook App

* QUIC
- \underline{Q}uick \underline{U}DP \underline{I}nternet
  \underline{C}onnections
- Transportprotokoll UDP!
- wird von IETF standardisiert (voraussichtlich 2021)
  - urspr√ºnglich von Google entwickelt
- Vorteile
  - reduzierte Latenz bei Verbindungsaufbau
  - bessere Performance (auch bei Verlust von Datenpaketen)
  - Von Anfang an verschl√ºsselt
- Nachteile
  - Reifegrad nicht so hoch wie bei TCP
  - "schwerer" f√ºr Router
    - sehen derzeit nur eine Folge von UDP Datagrams!
    - TCP hat im Gegensatz unverschl√ºsselte Header!

* QUIC -- Charakteristiken
- kein 3 Way Handshake beim Verbindungsaufbau
  - nur einfacher Handshake wie bei TLS, d.h.
    a. \to =ClientHello=
    b. \leftarrow =ServerHello=
    c. \to =Finished=
- mehrere Streams √ºber UDP (multiplexing)
  - Jeder Stream hat eigene Fehlerbehandlung
    - daher nicht das Problem wie bei TCP!
- IP Adressen k√∂nnen sich w√§hrend Betrieb √§ndern
  - da UDP
  - z.B. Smartphone wechselt von mobilen Netzwerk ins WLAN
- TLS 1.3 integriert
